name: Auto-merge Dependabot PRs (secure + patch)

# Runs on Dependabot PRs and evaluates whether it's safe to enable GitHub auto-merge.
# - Security updates: auto-merge after required checks pass
# - Patch updates: auto-merge after required checks pass
# - Major/minor updates: do NOT auto-merge
# Safety: only enable auto-merge if the target branch protection contains required checks (validate/test by default)

on:
  pull_request_target:
    types: [opened, reopened, synchronize, labeled]

permissions:
  contents: read
  checks: read
  pull-requests: write
  statuses: read

jobs:
  evaluate-and-enable:
    name: Evaluate Dependabot PR and enable auto-merge when safe
    runs-on: ubuntu-latest
    if: |
      github.event.pull_request.user.login == 'dependabot[bot]' ||
      github.event.pull_request.user.login == 'dependabot-preview[bot]'

    steps:
      - name: Evaluate PR (semver & branch-protection)
        id: evaluate
        uses: actions/github-script@v6
        with:
          script: |
            const pr = context.payload.pull_request;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Helper to strip non-numeric prefixes and return first semver
            const extractSemver = (v) => {
              if (!v || typeof v !== 'string') return null;
              const m = v.match(/(\d+\.\d+\.\d+)/);
              return m ? m[1] : null;
            };

            // Compare semver strings like '1.2.3'
            const cmpSemver = (a, b) => {
              if (!a || !b) return null;
              const pa = a.split('.').map(Number);
              const pb = b.split('.').map(Number);
              if (pa[0] !== pb[0]) return pa[0] - pb[0] > 0 ? 1 : -1;
              if (pa[1] !== pb[1]) return pa[1] - pb[1] > 0 ? 1 : -1;
              if (pa[2] !== pb[2]) return pa[2] - pb[2] > 0 ? 1 : -1;
              return 0;
            };

            // Identify package.json files changed in the PR
            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner, repo, pull_number: pr.number,
            });

            const pkgFiles = files.filter(f => f.filename.endsWith('package.json'))
                                   .map(f => f.filename);

            let hasMajor = false;
            let hasMinor = false;
            let hasPatch = false;

            for (const path of pkgFiles) {
              // get content on base and head
              let baseJson = null;
              let headJson = null;
              try {
                const baseResp = await github.rest.repos.getContent({ owner, repo, path, ref: pr.base.sha });
                const baseRaw = Buffer.from(baseResp.data.content, 'base64').toString();
                baseJson = JSON.parse(baseRaw);
              } catch (e) {
                // file may not exist on base
              }
              try {
                const headResp = await github.rest.repos.getContent({ owner, repo, path, ref: pr.head.sha });
                const headRaw = Buffer.from(headResp.data.content, 'base64').toString();
                headJson = JSON.parse(headRaw);
              } catch (e) {
                // file may not exist on head
              }

              const sections = ['dependencies', 'devDependencies', 'peerDependencies', 'optionalDependencies'];
              for (const sec of sections) {
                const baseDeps = baseJson && baseJson[sec] ? baseJson[sec] : {};
                const headDeps = headJson && headJson[sec] ? headJson[sec] : {};

                for (const pkg of Object.keys(headDeps)) {
                  const newV = headDeps[pkg];
                  const oldV = baseDeps[pkg];
                  if (!oldV) continue; // new dependency, treat as not patch
                  const sOld = extractSemver(oldV);
                  const sNew = extractSemver(newV);
                  if (!sOld || !sNew) {
                    // Couldn't parse semver â€” be conservative and treat as non-patch
                    hasMinor = true;
                    continue;
                  }
                  const cmp = cmpSemver(sNew, sOld);
                  if (cmp === null) {
                    hasMinor = true;
                  } else if (cmp > 0) {
                    // sNew > sOld
                    const oldParts = sOld.split('.').map(Number);
                    const newParts = sNew.split('.').map(Number);
                    if (newParts[0] > oldParts[0]) {
                      hasMajor = true;
                    } else if (newParts[1] > oldParts[1]) {
                      hasMinor = true;
                    } else if (newParts[2] > oldParts[2]) {
                      hasPatch = true;
                    }
                  }
                }
              }
            }

            // Determine security label
            const labels = (pr.labels || []).map(l => l.name.toLowerCase());
            const isSecurity = labels.includes('security') || pr.title.toLowerCase().includes('security') || (pr.body || '').toLowerCase().includes('security');

            const isPatchOnly = !hasMajor && !hasMinor && hasPatch;

            // Check branch protection required contexts include our required checks
            const requiredChecksToFind = ['validate', 'test'];
            let protectionContexts = [];
            let branchProtectionOk = false;
            try {
              const bp = await github.rest.repos.getBranchProtection({ owner, repo, branch: pr.base.ref });
              protectionContexts = bp.data.required_status_checks && bp.data.required_status_checks.contexts ? bp.data.required_status_checks.contexts : [];
              // Check that each required check string is present in at least one context name
              branchProtectionOk = requiredChecksToFind.every(rc => protectionContexts.some(c => c.toLowerCase().includes(rc)));
            } catch (err) {
              // If we cannot read branch protection (permissions), fallback to checking current PR check runs for presence of required names
              const checkRuns = await github.paginate(github.rest.checks.listForRef, { owner, repo, ref: pr.head.sha });
              const runNames = checkRuns.map(r => r.name.toLowerCase());
              branchProtectionOk = requiredChecksToFind.every(rc => runNames.some(rn => rn.includes(rc)));
            }

            const willAutoMerge = (isSecurity || isPatchOnly) && branchProtectionOk;

            // Output results
            core = require('@actions/core');
            core.setOutput('isSecurity', String(isSecurity));
            core.setOutput('hasMajor', String(hasMajor));
            core.setOutput('hasMinor', String(hasMinor));
            core.setOutput('hasPatch', String(hasPatch));
            core.setOutput('isPatchOnly', String(isPatchOnly));
            core.setOutput('protectionContexts', JSON.stringify(protectionContexts));
            core.setOutput('branchProtectionOk', String(branchProtectionOk));
            core.setOutput('willAutoMerge', String(willAutoMerge));

      - name: Skip and comment if not safe
        if: steps.evaluate.outputs.willAutoMerge != 'true'
        uses: actions/github-script@v6
        with:
          script: |
            const pr = context.payload.pull_request;
            const payload = {
              isSecurity: ${'{'}{ steps: { evaluate: { outputs: { isSecurity: '${{ steps.evaluate.outputs.isSecurity }}' } } } }'}
            };
            // Build a helpful comment
            const bpOk = '${{ steps.evaluate.outputs.branchProtectionOk }}' === 'true';
            const hasMajor = '${{ steps.evaluate.outputs.hasMajor }}' === 'true';
            const hasMinor = '${{ steps.evaluate.outputs.hasMinor }}' === 'true';
            const hasPatch = '${{ steps.evaluate.outputs.hasPatch }}' === 'true';
            let body = 'Dependabot auto-merge was NOT enabled for this PR.\n\n';
            if (!bpOk) body += '- Required branch protection checks not found (need `validate` and `test` contexts).\n';
            if (hasMajor) body += '- Contains one or more MAJOR updates (will not auto-merge).\n';
            else if (hasMinor) body += '- Contains one or more MINOR updates (will not auto-merge).\n';
            else if (!hasPatch && !('${{ steps.evaluate.outputs.isSecurity }}' === 'true')) body += '- No patch updates detected.\n';
            body += '\nIf you want to change auto-merge behavior, update the `.github/workflows/automerge-dependabot.yml` configuration.';
            await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number, body });

      - name: Enable auto-merge for safe Dependabot PRs
        if: steps.evaluate.outputs.willAutoMerge == 'true'
        uses: peter-evans/enable-pull-request-automerge@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          merge-method: squash

      - name: Comment when auto-merge enabled
        if: steps.evaluate.outputs.willAutoMerge == 'true'
        uses: actions/github-script@v6
        with:
          script: |
            const pr = context.payload.pull_request;
            const isSecurity = '${{ steps.evaluate.outputs.isSecurity }}' === 'true';
            const kind = isSecurity ? 'security' : 'patch';
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: `Auto-merge enabled for this Dependabot ${kind} update. It will merge automatically when required checks pass.`
            });
name: Auto-merge Dependabot PRs

on:
  pull_request_target:
    types: [opened, reopened, synchronize, labeled]

jobs:
  enable-automerge:
    name: Enable auto-merge for safe Dependabot PRs
    runs-on: ubuntu-latest
    # Only run for Dependabot authored PRs
    if: |
      github.event.pull_request.user.login == 'dependabot[bot]' ||
      github.event.pull_request.user.login == 'dependabot-preview[bot]'

    steps:
      - name: Check PR qualifies for auto-merge
        id: check
        uses: actions/github-script@v6
        with:
          script: |
            const core = require('@actions/core');
            const pr = context.payload.pull_request;
            const labels = (pr.labels || []).map(l => l.name.toLowerCase());
            const title = (pr.title || '').toLowerCase();
            const body = (pr.body || '').toLowerCase();

            // Heuristics for security or patch updates
            const isSecurity = labels.includes('security') || title.includes('security') || body.includes('security');
            const isPatchLabel = labels.includes('patch') || labels.includes('dependencies');
            const includesBump = title.includes('bump') || title.includes('upgrade');
            const isMajorHint = title.includes('major') || title.includes('breaking') || body.includes('breaking change');

            const isPatch = isPatchLabel || (includesBump && !isMajorHint);

            const should = isSecurity || isPatch;

            core.setOutput('should', should ? 'true' : 'false');
            core.setOutput('isSecurity', isSecurity ? 'true' : 'false');
            core.setOutput('isPatch', isPatch ? 'true' : 'false');

      - name: Enable GitHub auto-merge
        if: steps.check.outputs.should == 'true'
        uses: peter-evans/enable-pull-request-automerge@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          merge-method: squash

      - name: Comment when auto-merge enabled
        if: steps.check.outputs.should == 'true'
        uses: actions/github-script@v6
        with:
          script: |
            const pr = context.payload.pull_request;
            const isSecurity = '${{ steps.check.outputs.isSecurity }}' === 'true';
            const isPatch = '${{ steps.check.outputs.isPatch }}' === 'true';
            const kind = isSecurity ? 'security' : (isPatch ? 'patch' : 'other');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: `Auto-merge enabled for this Dependabot ${kind} update. It will merge automatically when required checks pass.`
            });
