name: Release

on:
  workflow_run:
    workflows: ["CI"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: write
  issues: write
  pull-requests: write

# Prevent multiple releases running simultaneously
concurrency:
  group: release
  cancel-in-progress: false

jobs:
  release:
    name: üöÄ Release
    runs-on: ubuntu-latest
    # Only run if CI workflow completed successfully
    if: |
      (github.event_name == 'workflow_dispatch') ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    outputs:
      release_created: ${{ steps.check_release.outputs.release_created }}
      release_tag: ${{ steps.check_release.outputs.release_tag }}

    env:
      SEMANTIC_RELEASE_BOT_APP_ID: ${{ secrets.SEMANTIC_RELEASE_BOT_APP_ID }}
      SEMANTIC_RELEASE_BOT_PRIVATE_KEY: ${{ secrets.SEMANTIC_RELEASE_BOT_PRIVATE_KEY }}
      SEMANTIC_RELEASE_BOT_APP_INSTALLATION_ID: ${{ secrets.SEMANTIC_RELEASE_BOT_APP_INSTALLATION_ID }}

    steps:
      - name: üì• Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          persist-credentials: true

      - name: üì• Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.19.0

      - name: üèó Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 24
          cache: 'pnpm'

      - name: üì¶ Install dependencies
        run: pnpm install --frozen-lockfile

      # Download build artifacts from CI workflow that triggered this release
      - name: üì• Download build artifacts from CI
        uses: dawidd6/action-download-artifact@v11
        with:
          workflow: ci.yml
          name: release-artifacts
          path: .
          workflow_conclusion: success

      # If artifacts don't exist, build them
      - name: üèó Build Release
        run: |
          if [ ! -f "dist.tar.gz" ] || [ ! -f "dist.zip" ]; then
            echo "Building Release artifacts..."
            pnpm install --frozen-lockfile
            pnpm run build
            cd dist && tar -czf ../dist.tar.gz . && cd ..
            zip -r dist.zip dist/
          else
            echo "Using existing release artifacts from CI"
          fi

      # Verify artifacts contain correct version
      - name: üîç Verify artifact version
        run: |
          echo "Verifying artifact contents..."
          if [ -f "dist.tar.gz" ]; then
            echo "Contents of dist.tar.gz:"
            tar -tzf dist.tar.gz | head -10
            # Extract temporarily to check version
            mkdir -p temp_dist
            tar -xzf dist.tar.gz -C temp_dist/
            if [ -f "temp_dist/index.html" ]; then
              echo "Checking for version in index.html..."
              grep -i "version\|${{ needs.release.outputs.tag }}" temp_dist/index.html || echo "Version not found in HTML"
            fi
            rm -rf temp_dist
          fi

      # Upload artifacts for deployment workflow
      - name: üì§ Upload release artifacts
        uses: actions/upload-artifact@v5
        with:
          name: release-artifacts
          path: |
            dist.tar.gz
            dist.zip
          retention-days: 7

      # Create a short-lived installation token from the GitHub App
      - name: üîê Create GitHub App installation token
        id: create_app_token
        run: |
          set -euo pipefail

          echo "Checking GitHub App secret presence (non-sensitive):"
          echo "- SEMANTIC_RELEASE_BOT_APP_ID set: ${SEMANTIC_RELEASE_BOT_APP_ID:+yes}" || true
          echo "- SEMANTIC_RELEASE_BOT_APP_INSTALLATION_ID set: ${SEMANTIC_RELEASE_BOT_APP_INSTALLATION_ID:+yes}" || true

          if [ -z "${SEMANTIC_RELEASE_BOT_APP_ID:-}" ] || [ -z "${SEMANTIC_RELEASE_BOT_PRIVATE_KEY:-}" ] || [ -z "${SEMANTIC_RELEASE_BOT_APP_INSTALLATION_ID:-}" ]; then
            echo "One of SEMANTIC_RELEASE_BOT_APP_ID, SEMANTIC_RELEASE_BOT_PRIVATE_KEY or SEMANTIC_RELEASE_BOT_APP_INSTALLATION_ID is empty. Please add the secrets to the repository." >&2
            exit 1
          fi

          # Create JWT using Node's crypto builtin to avoid external deps
          JWT=$(node -e "const crypto=require('crypto');const appId=process.env.SEMANTIC_RELEASE_BOT_APP_ID;const pk=process.env.SEMANTIC_RELEASE_BOT_PRIVATE_KEY.replace(/\r?\n/g,'\n');const header=Buffer.from(JSON.stringify({alg:'RS256',typ:'JWT'})).toString('base64').replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');const now=Math.floor(Date.now()/1000);const payload=Buffer.from(JSON.stringify({iat:now-60,exp:now+600,iss:parseInt(appId)})).toString('base64').replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');const data=header+'.'+payload;const sign=crypto.createSign('RSA-SHA256');sign.update(data);const sig=sign.sign(pk,'base64').replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');console.log(data+'.'+sig);")

          echo "JWT created"

          # Exchange JWT for an installation token
          RESP=$(curl -s -X POST "https://api.github.com/app/installations/${SEMANTIC_RELEASE_BOT_APP_INSTALLATION_ID}/access_tokens" -H "Authorization: Bearer ${JWT}" -H "Accept: application/vnd.github+json")

          TOKEN=$(echo "$RESP" | python -c 'import sys, json;print(json.load(sys.stdin).get("token", ""))')

          if [ -z "$TOKEN" ]; then
            echo "Failed to get installation token from GitHub API:" >&2
            echo "$RESP" >&2
            exit 1
          fi

          # Print a masked preview of the token length for diagnostics (do not print the token itself)
          echo "Got installation token of length: ${#TOKEN}"

          echo "token=$TOKEN" >> "$GITHUB_OUTPUT"

      - name: ‚ö†Ô∏è Verify App token and provide fallback logs
        run: |
          if [ -z "${{ steps.create_app_token.outputs.token }}" ]; then
            echo "ERROR: Installation token was not created."
            echo "Possible causes:"
            echo " - Secrets missing or malformed (SEMANTIC_RELEASE_BOT_APP_ID, SEMANTIC_RELEASE_BOT_PRIVATE_KEY, SEMANTIC_RELEASE_BOT_APP_INSTALLATION_ID)."
            echo " - The App installation does not have correct repository permissions (contents: write)."
            echo " - Organization policy prevents App-generated tokens from pushing to protected branches."
            echo "Suggested actions:" 
            echo " - Verify repo secrets in Settings ‚Üí Secrets ‚Üí Actions." 
            echo " - Confirm the App installation has 'Contents: Read & write' permission and is installed on this repo." 
            echo " - If branch protection still blocks pushes, add the App installation as an allowed actor in the branch protection rule or use a machine user PAT as a fallback."
            echo "Failing early to avoid attempting a release that will fail due to missing token." >&2
            exit 1
          else
            echo "Installation token available. Proceeding with release..."
          fi

      - name: üöÄ Run semantic-release
        env:
          GITHUB_TOKEN: ${{ steps.create_app_token.outputs.token }}
          GIT_AUTHOR_NAME: github-actions[bot]
          GIT_AUTHOR_EMAIL: github-actions[bot]@users.noreply.github.com
          GIT_COMMITTER_NAME: github-actions[bot]
          GIT_COMMITTER_EMAIL: github-actions[bot]@users.noreply.github.com
        run: pnpm exec semantic-release

      - name: üîç Check if release was created
        id: check_release
        run: |
          # Get the latest tag after semantic-release
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "none")
          echo "Latest tag: $LATEST_TAG"

          # Check if this tag was created in this run by comparing with the previous commit
          if [ "$LATEST_TAG" != "none" ]; then
            # Check if the latest commit message contains the release tag
            if git log -1 --oneline | grep -q "$LATEST_TAG"; then
              echo "‚úÖ Release was created: $LATEST_TAG"
              echo "release_created=true" >> $GITHUB_OUTPUT
              echo "release_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
            else
              echo "‚ÑπÔ∏è No new release created in this run"
              echo "release_created=false" >> $GITHUB_OUTPUT
              echo "release_tag=none" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ÑπÔ∏è No tags found"
            echo "release_created=false" >> $GITHUB_OUTPUT
            echo "release_tag=none" >> $GITHUB_OUTPUT
          fi

      - name: üìä Release Summary
        if: success()
        run: |
          echo "### üéâ Release Published!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "none")
          if [ "$LATEST_TAG" != "none" ]; then
            echo "**Version:** \`$LATEST_TAG\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üîó [View Release](https://github.com/${{ github.repository }}/releases/tag/$LATEST_TAG)" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ÑπÔ∏è No new release was created (no releasable commits since last release)" >> $GITHUB_STEP_SUMMARY
          fi

  trigger-deployments:
    name: üéØ Trigger Deployments
    needs: release
    if: success() && needs.release.outputs.release_created == 'true' && needs.release.outputs.release_tag != 'none' && needs.release.outputs.release_tag != ''
    runs-on: ubuntu-latest

    # Add permissions needed to trigger workflows
    permissions:
      contents: read
      actions: write

    env:
      SEMANTIC_RELEASE_BOT_APP_ID: ${{ secrets.SEMANTIC_RELEASE_BOT_APP_ID }}
      SEMANTIC_RELEASE_BOT_PRIVATE_KEY: ${{ secrets.SEMANTIC_RELEASE_BOT_PRIVATE_KEY }}
      SEMANTIC_RELEASE_BOT_APP_INSTALLATION_ID: ${{ secrets.SEMANTIC_RELEASE_BOT_APP_INSTALLATION_ID }}

    steps:
      - name: üì• Checkout
        uses: actions/checkout@v5

      - name: üîç Validate release artifacts
        run: |
          echo "Checking for release artifacts..."
          if [ ! -f "dist.tar.gz" ] && [ ! -f "dist.zip" ]; then
            echo "‚ùå No release artifacts found. Checking if they were uploaded by CI..."
            # Try to download from CI workflow artifacts
            echo "Attempting to download artifacts from CI workflow..."
            # This will be handled by the deployment workflow
          else
            echo "‚úÖ Release artifacts found locally"
            # Verify version in artifacts
            if [ -f "dist.tar.gz" ]; then
              echo "Checking version in dist.tar.gz..."
              tar -tzf dist.tar.gz | head -10
            fi
          fi

      - name: üöÄ Deploy Production
        uses: ./.github/workflows/azure-static-web-apps-blue-desert-06e30df03.yml
        with:
          environment: production
          release_tag: ${{ needs.release.outputs.release_tag }}
        secrets:
          AZURE_STATIC_WEB_APPS_API_TOKEN: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_BLUE_DESERT_06E30DF03 }}
