name: Release

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]
  workflow_dispatch:

permissions:
  contents: write
  issues: write
  pull-requests: write

# Prevent multiple releases running simultaneously
concurrency:
  group: release
  cancel-in-progress: false

jobs:
  release:
    name: üöÄ Release
    runs-on: ubuntu-latest
    # Only run if CI workflow completed successfully
    if: |
      github.event_name == 'push' ||
      github.event_name == 'workflow_dispatch'

    steps:
      - name: üì• Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          persist-credentials: true

      - name: üì• Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.19.0

      - name: üèó Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 24
          cache: 'pnpm'

      - name: üì¶ Install dependencies
        run: pnpm install --frozen-lockfile

      - name: üì• Download build artifacts from CI
        uses: dawidd6/action-download-artifact@v11
        with:
          workflow: ci.yml
          name: release-artifacts
          path: .
          workflow_conclusion: success

      # If artifacts don't exist, build them
      - name: üèó Build (if needed)
        run: |
          if [ ! -f "dist.tar.gz" ]; then
            echo "Building artifacts..."
            pnpm run build
            cd dist && tar -czf ../dist.tar.gz . && cd ..
            zip -r dist.zip dist/
          fi

      # Create a short-lived installation token from the GitHub App
      - name: üîê Create GitHub App installation token
        id: create_app_token
        env:
          GH_APP_ID: ${{ secrets.SEMANTIC_RELEASE_BOT_APP_ID }}
          GH_APP_PRIVATE_KEY: ${{ secrets.SEMANTIC_RELEASE_BOT_APP_PRIVATE_KEY }}
          GH_APP_INSTALLATION_ID: ${{ secrets.SEMANTIC_RELEASE_BOT_APP_INSTALLATION_ID }}
        run: |
          set -euo pipefail

          echo "Checking GitHub App secret presence:"
          echo "- GH_APP_ID set: ${GH_APP_ID:+yes}") || true
          echo "- GH_APP_INSTALLATION_ID set: ${GH_APP_INSTALLATION_ID:+yes}") || true

          if [ -z "${GH_APP_ID:-}" ] || [ -z "${GH_APP_PRIVATE_KEY:-}" ] || [ -z "${GH_APP_INSTALLATION_ID:-}" ]; then
            echo "One of GH_APP_ID, GH_APP_PRIVATE_KEY or GH_APP_INSTALLATION_ID is empty. Please add the secrets to the repository." >&2
            exit 1
          fi

          # Create JWT using Node's crypto builtin to avoid external deps
          JWT=$(node -e "const crypto=require('crypto');const appId=process.env.GH_APP_ID;const pk=process.env.GH_APP_PRIVATE_KEY.replace(/\r?\n/g,'\n');const header=Buffer.from(JSON.stringify({alg:'RS256',typ:'JWT'})).toString('base64').replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');const now=Math.floor(Date.now()/1000);const payload=Buffer.from(JSON.stringify({iat:now-60,exp:now+600,iss:parseInt(appId)})).toString('base64').replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');const data=header+'.'+payload;const sign=crypto.createSign('RSA-SHA256');sign.update(data);const sig=sign.sign(pk,'base64').replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');console.log(data+'.'+sig);")

          echo "JWT created"

          # Exchange JWT for an installation token
          RESP=$(curl -s -X POST "https://api.github.com/app/installations/${GH_APP_INSTALLATION_ID}/access_tokens" -H "Authorization: Bearer ${JWT}" -H "Accept: application/vnd.github+json")

          TOKEN=$(echo "$RESP" | python -c 'import sys, json;print(json.load(sys.stdin).get("token", ""))')

          if [ -z "$TOKEN" ]; then
            echo "Failed to get installation token from GitHub API:" >&2
            echo "$RESP" >&2
            exit 1
          fi

          # Print a masked preview of the token length for diagnostics (do not print the token itself)
          echo "Got installation token of length: ${#TOKEN}"

          echo "token=$TOKEN" >> "$GITHUB_OUTPUT"

      - name: ‚ö†Ô∏è Verify App token and provide fallback logs
        run: |
          if [ -z "${{ steps.create_app_token.outputs.token }}" ]; then
            echo "ERROR: Installation token was not created."
            echo "Possible causes:"
            echo " - Secrets missing or malformed (GH_APP_ID, GH_APP_PRIVATE_KEY, GH_APP_INSTALLATION_ID)."
            echo " - The App installation does not have correct repository permissions (contents: write)."
            echo " - Organization policy prevents App-generated tokens from pushing to protected branches."
            echo "Suggested actions:" 
            echo " - Verify repo secrets in Settings ‚Üí Secrets ‚Üí Actions." 
            echo " - Confirm the App installation has 'Contents: Read & write' permission and is installed on this repo." 
            echo " - If branch protection still blocks pushes, add the App installation as an allowed actor in the branch protection rule or use a machine user PAT as a fallback."
            echo "Failing early to avoid attempting a release that will fail due to missing token." >&2
            exit 1
          else
            echo "Installation token available. Proceeding with release..."
          fi

      - name: üöÄ Run semantic-release
        env:
          GITHUB_TOKEN: ${{ steps.create_app_token.outputs.token }}
          GIT_AUTHOR_NAME: github-actions[bot]
          GIT_AUTHOR_EMAIL: github-actions[bot]@users.noreply.github.com
          GIT_COMMITTER_NAME: github-actions[bot]
          GIT_COMMITTER_EMAIL: github-actions[bot]@users.noreply.github.com
        run: pnpm exec semantic-release

      - name: üìä Release Summary
        if: success()
        run: |
          echo "### üéâ Release Published!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "none")
          if [ "$LATEST_TAG" != "none" ]; then
            echo "**Version:** \`$LATEST_TAG\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üîó [View Release](https://github.com/${{ github.repository }}/releases/tag/$LATEST_TAG)" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ÑπÔ∏è No new release was created (no releasable commits since last release)" >> $GITHUB_STEP_SUMMARY
          fi

  trigger-deployments:
    name: üéØ Trigger Deployments
    needs: release
    if: success()
    runs-on: ubuntu-latest

    steps:
      - name: üì• Checkout
        uses: actions/checkout@v5

      - name: üîç Get latest release
        id: release
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "none")
          echo "tag=$LATEST_TAG" >> $GITHUB_OUTPUT

      - name: üöÄ Trigger deployments
        if: steps.release.outputs.tag != 'none'
        uses: actions/github-script@v8
        with:
          script: |
            const tag = '${{ steps.release.outputs.tag }}';

            // Trigger Azure Static Web Apps deployment
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'azure-static-web-apps-blue-desert-06e30df03.yml',
                ref: 'main',
                inputs: {
                  release_tag: tag
                }
              });
              console.log('‚úÖ Triggered Azure Static Web Apps deployment');
            } catch (error) {
              console.log('‚ö†Ô∏è Azure deployment trigger skipped:', error.message);
            }

            // Trigger GitHub Pages deployment
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'deploy-gh-pages.yml',
                ref: 'main',
                inputs: {
                  release_tag: tag
                }
              });
              console.log('‚úÖ Triggered GitHub Pages deployment');
            } catch (error) {
              console.log('‚ö†Ô∏è GitHub Pages deployment trigger skipped:', error.message);
            }

            console.log(`‚úÖ Deployment triggers completed for ${tag}`)
