name: Release

on:
  workflow_run:
    workflows: ["CI"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: write
  issues: write
  pull-requests: write

# Prevent multiple releases running simultaneously
concurrency:
  group: release
  cancel-in-progress: false

jobs:
  release:
    name: üöÄ Release
    runs-on: ubuntu-latest
    # Only run if CI workflow completed successfully
    if: |
      (github.event_name == 'workflow_dispatch') ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')

    env:
      SEMANTIC_RELEASE_BOT_APP_ID: ${{ secrets.SEMANTIC_RELEASE_BOT_APP_ID }}
      SEMANTIC_RELEASE_BOT_PRIVATE_KEY: ${{ secrets.SEMANTIC_RELEASE_BOT_PRIVATE_KEY }}
      SEMANTIC_RELEASE_BOT_APP_INSTALLATION_ID: ${{ secrets.SEMANTIC_RELEASE_BOT_APP_INSTALLATION_ID }}

    steps:
      - name: üì• Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          persist-credentials: true

      - name: üì• Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.19.0

      - name: üèó Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 24
          cache: 'pnpm'

      - name: üì¶ Install dependencies
        run: pnpm install --frozen-lockfile

      # - name: üì• Download build artifacts from CI
      #   uses: dawidd6/action-download-artifact@v11
      #   with:
      #     workflow: ci.yml
      #     name: release-artifacts
      #     path: .
      #     workflow_conclusion: success

      # If artifacts don't exist, build them
      - name: üèó Build Release
        run: |
          if [ ! -f "dist.tar.gz" ]; then
            echo "Building Release artifacts..."
            pnpm run build
            cd dist && tar -czf ../dist.tar.gz . && cd ..
            zip -r dist.zip dist/
          fi

      # Create a short-lived installation token from the GitHub App
      - name: üîê Create GitHub App installation token
        id: create_app_token
        run: |
          set -euo pipefail

          echo "Checking GitHub App secret presence (non-sensitive):"
          echo "- SEMANTIC_RELEASE_BOT_APP_ID set: ${SEMANTIC_RELEASE_BOT_APP_ID:+yes}" || true
          echo "- SEMANTIC_RELEASE_BOT_APP_INSTALLATION_ID set: ${SEMANTIC_RELEASE_BOT_APP_INSTALLATION_ID:+yes}" || true

          if [ -z "${SEMANTIC_RELEASE_BOT_APP_ID:-}" ] || [ -z "${SEMANTIC_RELEASE_BOT_PRIVATE_KEY:-}" ] || [ -z "${SEMANTIC_RELEASE_BOT_APP_INSTALLATION_ID:-}" ]; then
            echo "One of SEMANTIC_RELEASE_BOT_APP_ID, SEMANTIC_RELEASE_BOT_PRIVATE_KEY or SEMANTIC_RELEASE_BOT_APP_INSTALLATION_ID is empty. Please add the secrets to the repository." >&2
            exit 1
          fi

          # Create JWT using Node's crypto builtin to avoid external deps
          JWT=$(node -e "const crypto=require('crypto');const appId=process.env.SEMANTIC_RELEASE_BOT_APP_ID;const pk=process.env.SEMANTIC_RELEASE_BOT_PRIVATE_KEY.replace(/\r?\n/g,'\n');const header=Buffer.from(JSON.stringify({alg:'RS256',typ:'JWT'})).toString('base64').replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');const now=Math.floor(Date.now()/1000);const payload=Buffer.from(JSON.stringify({iat:now-60,exp:now+600,iss:parseInt(appId)})).toString('base64').replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');const data=header+'.'+payload;const sign=crypto.createSign('RSA-SHA256');sign.update(data);const sig=sign.sign(pk,'base64').replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');console.log(data+'.'+sig);")

          echo "JWT created"

          # Exchange JWT for an installation token
          RESP=$(curl -s -X POST "https://api.github.com/app/installations/${SEMANTIC_RELEASE_BOT_APP_INSTALLATION_ID}/access_tokens" -H "Authorization: Bearer ${JWT}" -H "Accept: application/vnd.github+json")

          TOKEN=$(echo "$RESP" | python -c 'import sys, json;print(json.load(sys.stdin).get("token", ""))')

          if [ -z "$TOKEN" ]; then
            echo "Failed to get installation token from GitHub API:" >&2
            echo "$RESP" >&2
            exit 1
          fi

          # Print a masked preview of the token length for diagnostics (do not print the token itself)
          echo "Got installation token of length: ${#TOKEN}"

          echo "token=$TOKEN" >> "$GITHUB_OUTPUT"

      - name: ‚ö†Ô∏è Verify App token and provide fallback logs
        run: |
          if [ -z "${{ steps.create_app_token.outputs.token }}" ]; then
            echo "ERROR: Installation token was not created."
            echo "Possible causes:"
            echo " - Secrets missing or malformed (SEMANTIC_RELEASE_BOT_APP_ID, SEMANTIC_RELEASE_BOT_PRIVATE_KEY, SEMANTIC_RELEASE_BOT_APP_INSTALLATION_ID)."
            echo " - The App installation does not have correct repository permissions (contents: write)."
            echo " - Organization policy prevents App-generated tokens from pushing to protected branches."
            echo "Suggested actions:" 
            echo " - Verify repo secrets in Settings ‚Üí Secrets ‚Üí Actions." 
            echo " - Confirm the App installation has 'Contents: Read & write' permission and is installed on this repo." 
            echo " - If branch protection still blocks pushes, add the App installation as an allowed actor in the branch protection rule or use a machine user PAT as a fallback."
            echo "Failing early to avoid attempting a release that will fail due to missing token." >&2
            exit 1
          else
            echo "Installation token available. Proceeding with release..."
          fi

      - name: üöÄ Run semantic-release
        env:
          GITHUB_TOKEN: ${{ steps.create_app_token.outputs.token }}
          GIT_AUTHOR_NAME: github-actions[bot]
          GIT_AUTHOR_EMAIL: github-actions[bot]@users.noreply.github.com
          GIT_COMMITTER_NAME: github-actions[bot]
          GIT_COMMITTER_EMAIL: github-actions[bot]@users.noreply.github.com
        run: pnpm exec semantic-release

      - name: üìä Release Summary
        if: success()
        run: |
          echo "### üéâ Release Published!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "none")
          if [ "$LATEST_TAG" != "none" ]; then
            echo "**Version:** \`$LATEST_TAG\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üîó [View Release](https://github.com/${{ github.repository }}/releases/tag/$LATEST_TAG)" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ÑπÔ∏è No new release was created (no releasable commits since last release)" >> $GITHUB_STEP_SUMMARY
          fi

  trigger-deployments:
    name: üéØ Trigger Deployments
    needs: release
    if: success()
    runs-on: ubuntu-latest

    # Add permissions needed to trigger workflows
    permissions:
      contents: read
      actions: write

    env:
      SEMANTIC_RELEASE_BOT_APP_ID: ${{ secrets.SEMANTIC_RELEASE_BOT_APP_ID }}
      SEMANTIC_RELEASE_BOT_PRIVATE_KEY: ${{ secrets.SEMANTIC_RELEASE_BOT_PRIVATE_KEY }}
      SEMANTIC_RELEASE_BOT_APP_INSTALLATION_ID: ${{ secrets.SEMANTIC_RELEASE_BOT_APP_INSTALLATION_ID }}

    steps:
      - name: üì• Checkout
        uses: actions/checkout@v5

      - name: üîç Get latest release
        id: release
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "none")
          echo "tag=$LATEST_TAG" >> $GITHUB_OUTPUT

      # Create installation token for deployment triggering
      - name: üîê Create deployment token
        id: create_deploy_token
        run: |
          set -euo pipefail

          if [ -z "${SEMANTIC_RELEASE_BOT_APP_ID:-}" ] || [ -z "${SEMANTIC_RELEASE_BOT_PRIVATE_KEY:-}" ] || [ -z "${SEMANTIC_RELEASE_BOT_APP_INSTALLATION_ID:-}" ]; then
            echo "GitHub App secrets not available, falling back to GITHUB_TOKEN"
            echo "token=${{ secrets.GITHUB_TOKEN }}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Create JWT using Node's crypto builtin
          JWT=$(node -e "const crypto=require('crypto');const appId=process.env.SEMANTIC_RELEASE_BOT_APP_ID;const pk=process.env.SEMANTIC_RELEASE_BOT_PRIVATE_KEY.replace(/\r?\n/g,'\n');const header=Buffer.from(JSON.stringify({alg:'RS256',typ:'JWT'})).toString('base64').replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');const now=Math.floor(Date.now()/1000);const payload=Buffer.from(JSON.stringify({iat:now-60,exp:now+600,iss:parseInt(appId)})).toString('base64').replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');const data=header+'.'+payload;const sign=crypto.createSign('RSA-SHA256');sign.update(data);const sig=sign.sign(pk,'base64').replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');console.log(data+'.'+sig);")

          # Exchange JWT for an installation token
          RESP=$(curl -s -X POST "https://api.github.com/app/installations/${SEMANTIC_RELEASE_BOT_APP_INSTALLATION_ID}/access_tokens" -H "Authorization: Bearer ${JWT}" -H "Accept: application/vnd.github+json")

          TOKEN=$(echo "$RESP" | python -c 'import sys, json;print(json.load(sys.stdin).get("token", ""))')

          if [ -z "$TOKEN" ]; then
            echo "Failed to get installation token, falling back to GITHUB_TOKEN"
            echo "token=${{ secrets.GITHUB_TOKEN }}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "token=$TOKEN" >> "$GITHUB_OUTPUT"

      - name: ÔøΩ Validate deployment workflow exists
        run: |
          WORKFLOW_FILE=".github/workflows/azure-static-web-apps-blue-desert-06e30df03.yml"
          if [ ! -f "$WORKFLOW_FILE" ]; then
            echo "‚ùå Deployment workflow file not found: $WORKFLOW_FILE"
            echo "Available workflow files:"
            ls -la .github/workflows/ || true
            exit 1
          fi
          echo "‚úÖ Deployment workflow file exists: $WORKFLOW_FILE"

      - name: ÔøΩüöÄ Trigger deployment
        if: steps.release.outputs.tag != 'none'
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.create_deploy_token.outputs.token }}
          script: |
            const tag = '${{ steps.release.outputs.tag }}';
            const workflowId = 'azure-static-web-apps-blue-desert-06e30df03.yml';

            console.log(`üöÄ Triggering deployment for release: ${tag}`);

            try {
              // First, verify the workflow exists and is accessible
              const workflows = await github.rest.actions.listRepoWorkflows({
                owner: context.repo.owner,
                repo: context.repo.repo
              });

              const targetWorkflow = workflows.data.workflows.find(w => w.path.endsWith(workflowId));
              if (!targetWorkflow) {
                throw new Error(`Workflow ${workflowId} not found. Available workflows: ${workflows.data.workflows.map(w => w.path).join(', ')}`);
              }

              console.log(`‚úÖ Found target workflow: ${targetWorkflow.path} (ID: ${targetWorkflow.id})`);

              // Trigger the deployment workflow
              const result = await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: workflowId,
                ref: 'main',
                inputs: {
                  release_tag: tag
                }
              });

              console.log(`‚úÖ Successfully triggered Azure Static Web Apps deployment for ${tag}`);
              console.log(`üìã Workflow dispatch result: ${result.status}`);

            } catch (error) {
              console.error(`‚ùå Failed to trigger deployment: ${error.message}`);
              if (error.response) {
                console.error(`HTTP ${error.response.status}: ${JSON.stringify(error.response.data, null, 2)}`);
              }
              // Make the step fail so the release process doesn't silently continue
              process.exit(1);
            }
